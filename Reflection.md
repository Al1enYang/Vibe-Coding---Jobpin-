1. 哪些部分你基本是「完全交给 AI 写」的？你对这些代码的理解程度如何？
 # 项目脚手架和基础目录结构
 例如 App Router 的路由组织、layout/page 的拆分、组件目录结构等。

 # 第一次接触容易踩坑的地方
 例如 Clerk 集成与路由保护， Supabase 表结构与基础 CRUD 封装，Stripe Checkout / Webhook / Portal 的骨架代码

 # 简单的Ui实现
 例如 前端 Onboarding/Dashboard UI 的基础实现

 理解程度：
 # 理解较好
 页面UI设计和实现，用户的基本交互，UI状态管理

 # 理解一般
 Stripe webhook 的事件类型与状态同步、Supabase 的权限/服务端写入边界等等

 # 理解较弱
 外部 PDF 解析/LLM 的异常形态等相关配置和处理

2. 回头看我最不放心的模块是哪一块？如果上线到生产，我会怎么重构？
 # Stripe webhook 同步
 webhook 延迟或丢失容易导致 Dashboard 状态不同步。

 若上线到生产，我应该会找解决方案让 Stripe 和应用之间 更有效的交互和同步状态，比如增加定期 reconcile 拉取用户订阅状态校验并修正

3. AI 在哪些地方帮了大忙？哪些地方明显不太给力
 # 把需求拆成可执行任务
 高效地分析 + 精准地拆分任务，将用户需求转化成一步一步可以执行的开发流程

 # 快速生成集成骨架
 类似 Clerk/Stripe/Supabase 这种“配置文件多、集成步骤长”的模块，AI 能迅速落实生成一个 read to use 的开发环境。

 # debug 的效率提升
 高效扫描项目 + 锁定问题源，甚至 AI 能通过日志线索迅速定位并给出最小修复方向。

 # 相关文档生成
 README、验收清单、运行说明、环境变量说明等，AI 能一次性整理

 AI 不太给力的地方
 # 复杂业务细节容易自作主张自己幻想
 如果没有明确边界，AI很容易按自己逻辑进行开发，通常需要返工

 # 反应问题后无效的更改
 有时没法一次性将问题解决，多次迭代后原地踏步

 # 长代码一致性
 上下文一长的情况下再多轮迭代后 AI 可能会出现字段名不统一或不同步等现象

 
 